pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
spec:
  # Service Account Name to insert will be provided once previous steps are completed (refer to step 2)
  serviceAccountName: ospr-coin
  restartPolicy: Never
  containers:
  # Add more containers to complete the job
  - name: awscli
    image: mikesir87/aws-cli:2.0.25
    command: ['cat']
    tty: true
  - name: terraform
    image: hashicorp/terraform:0.12.29
    command: ['cat']
    tty: true
"""
    }
  }
  stages {
    // Add any other stages and/or steps to complete the job
    stage('aws config') {
      steps {
        script{
            switch(env.environment) {
              case 'dev':
                env.iamrole = "arn:aws-us-gov:iam::169669953619:role/coin_devops_cbc_master_role"
                break
              case 'test':
                env.iamrole = "arn:aws-us-gov:iam::367095983308:role/coin_devops_cbc_master_role"
                break
              case 'impl':
                env.iamrole = "arn:aws-us-gov:iam::367185544840:role/coin_devops_cbc_master_role"
                break
              case 'prod':
                env.iamrole = "arn:aws-us-gov:iam::367362559545:role/coin_devops_cbc_master_role"
                break        
            }
        }
      }
    }
   

    stage('update iam') {
      steps {
        container('awscli') {
          script {
            sh '''
          aws sts assume-role \
           --role-arn ${iamrole} \
           --role-session-name session \
          > /tmp/assume-role.json
          cat /tmp/assume-role.json
          cat > .aws-creds <<EOF
          [default]
          aws_access_key_id = $(jq -r .Credentials.AccessKeyId /tmp/assume-role.json)
          aws_secret_access_key = $(jq -r .Credentials.SecretAccessKey /tmp/assume-role.json)
          aws_session_token = $(jq -r .Credentials.SessionToken /tmp/assume-role.json)
          EOF
       
          # Run AWS command to test the assume role.
          # cat .aws-creds
          # mkdir -p $HOME/.aws
          # cp -v .aws-creds $HOME/.aws/credentials
          # unset AWS_WEB_IDENTITY_TOKEN_FILE
          # aws ec2 describe-instances
          # aws s3 ls
          # Output should return resources in target AWS account (ADO's).
          '''
        }
      }
    }
    }
    stage('deploy infrastructure') {
      steps {
        container('terraform') {
          sh '''
          mkdir -p $HOME/.aws
          cp -v .aws-creds $HOME/.aws/credentials
          unset AWS_WEB_IDENTITY_TOKEN_FILE
          terraform -v
          '''
          sh 'rm -rf .terraform'
          sh 'terraform init'
          sh "terraform workspace select ${params.environment} || terraform workspace new ${params.environment}"
         // sh 'terraform state replace-provider   registry.terraform.io/-/template  registry.terraform.io/hashicorp/template'
          //sh 'terraform state replace-provider registry.terraform.io/-/aws registry.terraform.io/hashicorp/aws'
          //sh 'terraform untaint aws_instance.proxy_1a'
          //sh 'terraform untaint aws_instance.proxy_1b'
          sh "unset AWS_WEB_IDENTITY_TOKEN_FILE; terraform plan -var-file=${params.environment}-inputs.tfvars -var region=us-gov-west-1 -out plan.out"
          script {
            def deploy_validation = input(
              id: 'Deploy',
              message: 'Let\'s continue to deploy plan',
              type: "boolean")
              sh 'unset AWS_WEB_IDENTITY_TOKEN_FILE; terraform apply plan.out'
        }
        }
      }
    }    
  }
  parameters {
    choice(choices: ['dev', 'test', 'impl', 'prod'], description: 'What environment?', name: 'environment')
  }
}

